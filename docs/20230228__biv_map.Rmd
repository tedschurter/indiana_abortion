---
title: 'Bivariate map: median income and abortion rate by Indiana county'
author: "Ted Schurter"
date: "`r Sys.Date()`"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_float: true
    toc_depth: 3 
    theme: lumen
  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

<br>

This notebook outlines the process used and choices made to create a bivariate choropleth map showing median household income and median abortion rate per Indiana county from 2017 to 2021. 

A choropleth map uses a range of color to visualize the range of values within the same variable. In contrast, a bivariate map uses different colors to show the relationship between two variables. 

To create a bivariate map with nine classes, each variable must be sorted into three categories: low, medium and high. Where the dividing lines for these rankings are drawn impacts how the data are interpreted visually. 
```{r load libraries, echo=TRUE}
library(classInt)
library(cowplot)
library(DT)
library(tidyverse)
library(tidycensus)
library(ggplot2)
library(ggtext)
library(readr)
library(mapview)
library(sf)
library(tigris)
```
<br>

***

### The data

The abortion data is loaded from [per_cap.csv](https://github.com/tedschurter/indiana_abortion/blob/main/Exported_Data/per_cap.csv) that was created from this [script](https://github.com/tedschurter/indiana_abortion/blob/main/Scripts/20221025_Indiana_abortion_2014_2021.R) used to calculate the abortion rate for each county in Indiana from 2014 to 2021. For this map, it will be filtered to 2017 to 2021 to align with the years the income data was collected. 
```{r import abortion rate data, echo=TRUE}
per_cap <- read_csv("Exported_Data/per_cap.csv")

# filter years to 2017:2021

per_cap <- per_cap %>% filter(year %in% 2017:2021) %>% select (-geometry)
```
<br>
The median household income data comes from the five year [American Community Survey](https://www.socialexplorer.com/data/ACS2010_5yr/metadata/?ds=ACS10_5yr&var=B19013001). 
<br>

***

### Abortion data



How are the abortion data distributed? The histogram provides a count of how many times a given rate appears in the data set. There are 92 counties being counted over five years for a total of 460 different rates.
```{r fig.height = 4, echo=T}
ggplot(per_cap, aes(rate))+
  geom_histogram()
```
<br>
The data skew to the right with clear outliers. The data will be divided both ways - with and without the outliers - to better see the outliers' impact on the location of our low, medium and high dividing lines. 

To remove outlier rates, multiply the interquartile range - the distance between the 25th and 75th percentile - by 1.5 and filter rates that fall that amount below the first and above the third quartile.
```{r calculate abortion rate stats, echo = T}
# measurements for entire data set

ab_st_d <- sd(per_cap$rate)  # standard deviation
ab_mn <- mean(per_cap$rate) # mean
ab_median <- median(per_cap$rate) # median
ab_iqr <- IQR(per_cap$rate) # # interquartile range (distance between 25 and 75 percentiles)
pc_quant <- quantile(per_cap$rate) # quantiles 

# create per_cap2 dataframe for data with outliers removed

per_cap2 <-  per_cap %>% 
  filter(rate >= quantile(per_cap$rate)[2] - (ab_iqr*1.5)) %>% 
  filter(rate <= quantile(per_cap$rate)[3] + (ab_iqr*1.5))

# filtered measurements denoted by suffix _2

# assign measurements of location to objects
ab_st_d_2 <- sd(per_cap2$rate)  # filtered standard deviation
ab_median_2 <- median(per_cap2$rate) # filtered median
ab_mn_2 <- mean(per_cap2$rate) # filtered mean
ab_iqr_2 <- IQR(per_cap2$rate) # filtered IQR


```
<br>
Increasing the bin size of the histogram will provide more detail about the frequency of rates. A solid blue lines indicates the unfiltered mean, the dashed blue line represents the mean calculated after removing outliers. The yellow line is the median. Data within the shaded gray represent outliers.
```{r outliers, echo=T, fig.height = 4, out.width="100%"}

ggplot(per_cap, aes(rate))+
  geom_histogram(bins=92)+
  geom_vline(xintercept = ab_mn, color = "blue")+ # mean
  geom_vline(xintercept = ab_median, color = "yellow")+ # median
  geom_vline(xintercept = ab_mn_2, color = "blue", linetype = "dashed")+ # mean
  geom_vline(xintercept = ab_median_2, color = "yellow", linetype="dashed")+
  annotate("rect", xmin=0, xmax=quantile(per_cap$rate)[2] - (ab_iqr*1.5),
           ymin = 0, ymax = 25, alpha = .15, fill = "gray")+
  annotate("rect", xmin=quantile(per_cap$rate)[3] + (ab_iqr*1.5), 
           xmax=max(per_cap$rate),
           ymin = 0, ymax = 25, alpha = .15, fill = "gray")+
  labs(subtitle = "Outliers in shaded gray area")+
  xlim(0, max(per_cap$rate))+
  theme_classic()
```
<br>

#### Comparing the abortion data measurements with and without outliers removed: <br>

**Category**|**Original<br>data**|**1.5 \*\IQR Outliers<br>removed**|
:---|:---|:---|
**Number of counties**|`r per_cap %>% count(Name) %>% summarise(sum(n))`|`r per_cap2 %>% count(Name) %>% summarise(sum(n))`
**Mean**|`r round(ab_mn,2)`|`r round(ab_mn_2,2)`
**Standard Deviation**| `r round(ab_st_d,2)`|`r round(ab_st_d_2,2)`
**Interquartile Range**| `r ab_iqr`|`r ab_iqr_2`
**Range**|`r range(per_cap$rate)`|`r range(per_cap2$rate)`
<br><br>
A handful of counties are responsible for the right skew of the data and have an outsize impact on the range.

***
<br>

### Classifying abortion data into low, medium and high categories


#### Divide abortion rate using standard deviation

Using standard deviation to divide the abortion rate into three classes would locate all values falling one standard deviation below the mean into the low category, rates within one standard devation of the mean in the medium category, and rates one standard deviation above the mean in the high category. 

```{r sd, echo=T, fig.height=4, out.width="50%"}
ggplot(per_cap, aes(rate))+
  geom_histogram(bins=92)+
  geom_vline(xintercept = ab_mn, color = "blue")+ # mean
  geom_vline(xintercept = ab_median, color = "yellow")+ # median
  annotate("rect", xmin=min(per_cap$rate), xmax=ab_mn-ab_st_d,
           ymin = 0, ymax = 25, alpha = .15, fill = "green")+
  annotate("rect", xmin=ab_mn-ab_st_d, xmax=ab_st_d+ab_mn,
           ymin = 0, ymax = 25, alpha = .15, fill = "blue")+
  annotate("rect", xmin=ab_mn+ab_st_d, xmax=max(per_cap$rate),
           ymin = 0, ymax = 25, alpha = .15, fill = "red")+
  labs(subtitle = "raw data")+
  theme_classic()

ggplot(per_cap, aes(rate))+
  geom_histogram(bins=92)+
  geom_vline(xintercept = ab_mn, color = "blue")+ # mean
  geom_vline(xintercept = ab_mn_2, color = "blue", linetype = "dashed")+
  geom_vline(xintercept = ab_median, color = "yellow")+ # median
  annotate("rect", xmin=min(per_cap$rate), xmax=ab_mn_2-ab_st_d_2,
           ymin = 0, ymax = 25, alpha = .15, fill = "green")+
  annotate("rect", xmin=ab_mn_2-ab_st_d_2, xmax=ab_st_d_2+ab_mn_2,
           ymin = 0, ymax = 25, alpha = .15, fill = "blue")+
  annotate("rect", xmin=ab_mn_2+ab_st_d_2, xmax=max(per_cap$rate),
           ymin = 0, ymax = 25, alpha = .15, fill = "red")+
  labs(subtitle = "filtered data")+
  theme_classic()
```

<br><br>

##### Count of counties with different abortion rate categories 

**Method**|**Low Counties**|**Medium Counties**|**High Counties**
:---|:---|:---|:---|
**Standard deviation**|`r per_cap %>% filter(rate < ab_mn-ab_st_d) %>% count(rate) %>% summarise(sum(n))`  |`r per_cap %>% filter(between(rate, ab_mn-ab_st_d, ab_mn+ab_st_d)) %>% count(rate) %>% summarise(sum(n))`  |`r per_cap %>% filter(rate > ab_mn+ab_st_d) %>% count(rate) %>% summarise(sum(n))`  
**Standard deviation with outliers removed**|`r per_cap %>% filter(rate < ab_mn_2-ab_st_d_2) %>% count(rate) %>% summarise(sum(n))`  |`r per_cap %>% filter(between(rate, ab_mn_2-ab_st_d_2, ab_mn_2+ab_st_d_2)) %>% count(rate) %>% summarise(sum(n))`  |`r per_cap %>% filter(rate > ab_mn_2+ab_st_d_2) %>% count(rate) %>% summarise(sum(n))`  
*** 

#### Divide abortion rate into thirds

An alternative approach to using standard deviation to categorize low, medium and high rates would be to divide the rate into thirds. 
```{r calculate thirds, echo=T}
# determine range of rate
og_inc <- range(per_cap$rate)[2]-range(per_cap$rate)[1]

# assign lower third rate and middle third rate to object
lw_trd <- og_inc * .333                            
md_trd <- og_inc * (2*.333 )

# repeat for data with 1.5*IQR outliers removed

f_inc <- range(per_cap2$rate)[2]-range(per_cap2$rate)[1]

f_lw_trd <-  f_inc *.333
f_md_trd <- f_inc * (2*.333)
```

```{r histogram with thirds, fig.height = 4, out.width="50%"}
ggplot(per_cap, aes(rate))+
  geom_histogram(bins=92)+
  geom_vline(xintercept = mean(per_cap$rate), color = "blue")+
  geom_vline(xintercept = mean(per_cap2$rate), color = "blue", linetype = "dashed")+
   geom_vline(xintercept = median(per_cap$rate), color = "yellow")+
  annotate("rect", xmin=min(per_cap$rate), xmax=lw_trd, # filtered middle third
          ymin = 0, ymax = 25, alpha = .15, fill = "green")+
  annotate("rect", xmin=lw_trd, xmax=md_trd, # filtered middle third
          ymin = 0, ymax = 25, alpha = .15, fill = "blue")+
  annotate("rect", xmin=md_trd, xmax=max(per_cap$rate), # filtered middle third
          ymin = 0, ymax = 25, alpha = .15, fill = "red")+
  labs(subtitle = "thirds")+
  theme_classic()

ggplot(per_cap, aes(rate))+
  geom_histogram(bins=92)+
  geom_vline(xintercept = mean(per_cap$rate), color = "blue")+
  geom_vline(xintercept = mean(per_cap2$rate), color = "blue", linetype = "dashed")+
   geom_vline(xintercept = median(per_cap$rate), color = "yellow")+
  annotate("rect", xmin=min(per_cap$rate), xmax=f_lw_trd, # filtered middle third
          ymin = 0, ymax = 25, alpha = .15, fill = "green")+
  annotate("rect", xmin=f_lw_trd, xmax=f_md_trd, # filtered middle third
          ymin = 0, ymax = 25, alpha = .15, fill = "blue")+
  annotate("rect", xmin=f_md_trd, xmax=max(per_cap$rate), # filtered middle third
          ymin = 0, ymax = 25, alpha = .15, fill = "red")+
  labs(subtitle = "thirds filtered data")+
  theme_classic()
```

<br><br>

##### Count of counties with different abortion rate categories 

**Method**|**Low counties**|**Medium counties**|**High counties**
:---|:---|:---|:---|
**Standard deviation**|`r per_cap %>% filter(rate < ab_mn-ab_st_d) %>% count(rate) %>% summarise(sum(n))`  |`r per_cap %>% filter(between(rate, ab_mn-ab_st_d, ab_mn+ab_st_d)) %>% count(rate) %>% summarise(sum(n))`  |`r per_cap %>% filter(rate > ab_mn+ab_st_d) %>% count(rate) %>% summarise(sum(n))`  
**Standard deviation with outliers removed**|`r per_cap %>% filter(rate < ab_mn_2-ab_st_d_2) %>% count(rate) %>% summarise(sum(n))`  |`r per_cap %>% filter(between(rate, ab_mn_2-ab_st_d_2, ab_mn_2+ab_st_d_2)) %>% count(rate) %>% summarise(sum(n))`  |`r per_cap %>% filter(rate > ab_mn_2+ab_st_d_2) %>% count(rate) %>% summarise(sum(n))` 
||
||
**Thirds**|`r per_cap %>% filter(rate < lw_trd) %>% count(rate) %>% summarise(sum(n))`  |`r per_cap %>% filter(between(rate, lw_trd, md_trd)) %>% count(rate) %>% summarise(sum(n))`  |`r per_cap %>% filter(rate > md_trd) %>% count(rate) %>% summarise(sum(n))`  
**Thirds with outliers removed**|`r per_cap %>% filter(rate < f_lw_trd) %>% count(rate) %>% summarise(sum(n))`  |`r per_cap %>% filter(between(rate, f_lw_trd, f_md_trd)) %>% count(rate) %>% summarise(sum(n))`  |`r per_cap %>% filter(rate > f_md_trd) %>% count(rate) %>% summarise(sum(n))`  

***

##### Dividing the abortion rate using Jenks

Another way to divide the data is to use the [jenks natural breaks](http://wiki.gis.com/wiki/index.php/Jenks_Natural_Breaks_Classification) method. 

```{r, jenks_function, fig.show="hide", echo=TRUE}

# load function for jenks breaks
# from: http://cainarchaeology.weebly.com/r-function-for-plotting-jenks-natural-breaks-classification.html

plotJenks <- function(data, n=3, brks.cex=0.70, top.margin=10, dist=5){
  df <- data.frame(sorted.values=sort(data, decreasing=TRUE))
  Jclassif <- classIntervals(df$sorted.values, n, style = "jenks") #requires the 'classInt' package
  test <- jenks.tests(Jclassif) #requires the 'classInt' package
  df$class <- cut(df$sorted.values, unique(Jclassif$brks), labels=FALSE, include.lowest=TRUE) #the function unique() is used to remove non-unique breaks, should the latter be produced. This is done because the cut() function cannot break the values into classes if non-unique breaks are provided
  if(length(Jclassif$brks)!=length(unique(Jclassif$brks))){
    info <- ("The method has produced non-unique breaks, which have been removed. Please, check '...$classif$brks'")
  } else {info <- ("The method did not produce non-unique breaks.")}
  loop.res <- numeric(nrow(df))
  i <- 1
  repeat{
    i <- i+1
    loop.class <- classIntervals(df$sorted.values, i, style = "jenks")
    loop.test <- jenks.tests(loop.class)
    loop.res[i] <- loop.test[[2]]
    if(loop.res[i]>0.9999){
      break
    }
  }
  max.GoF.brks <- which.max(loop.res)
  plot(x=df$sorted.values, y=c(1:nrow(df)), type="b", main=paste0("Jenks natural breaks optimization; number of classes: ", n), sub=paste0("Goodness of Fit: ", round(test[[2]],4), ". Max GoF (", round(max(loop.res),4), ") with classes:", max.GoF.brks), ylim =c(0, nrow(df)+top.margin), cex=0.75, cex.main=0.95, cex.sub=0.7, ylab="observation index", xlab="value (increasing order)")
  abline(v=Jclassif$brks, lty=3, col="red")
  text(x=Jclassif$brks, y= max(nrow(df)) + dist, labels=sort(round(Jclassif$brks, 2)), cex=brks.cex, srt=90)
  results <- list("info"=info, "classif" = Jclassif, "breaks.max.GoF"=max.GoF.brks, "class.data" = df)
  return(results)
}

```

```{r include=FALSE, jenks_breaks}

# calculate natural breaks for non-filtered data

res <- plotJenks(data = per_cap$rate, n=3, brks.cex = .7, top.margin = 10, dist = 5)

# assign break values 

jnks_lw <- res$classif$brks[2]
jnks_md <- res$classif$brks[3]

# calculate natural breaks for filtered data

f_res <- plotJenks(data = per_cap2$rate, n=3, brks.cex = .7, top.margin = 10, dist = 5)

# assign break values for filtered data

f_jnks_lw <- f_res$classif$brks[2]
f_jnks_md <- f_res$classif$brks[3]

```

The distribution with jenks natural breaks.

```{r jenks_plot, echo=FALSE, fig.height= 4, out.width="50%"}
ggplot(per_cap, aes(rate))+
  geom_histogram(bins=92)+
  annotate("rect", xmin=0, xmax=jnks_lw, # jenks low
           ymin = 0, ymax = 25, alpha = .25, fill = "lime green")+
  annotate("rect", xmin=jnks_lw, xmax=jnks_md, # jenks low
           ymin = 0, ymax = 25, alpha = .25, fill = "blue")+
  annotate("rect", xmin=jnks_md, xmax=max(per_cap$rate), # jenks low
           ymin = 0, ymax = 25, alpha = .25, fill = "red")+
  labs(subtitle = "jenks")+
  theme_classic()

ggplot(per_cap, aes(rate))+
  geom_histogram(bins=92)+
  annotate("rect", xmin=0, xmax=f_jnks_lw, # jenks low
           ymin = 0, ymax = 25, alpha = .25, fill = "lime green")+
  annotate("rect", xmin=f_jnks_lw, xmax=f_jnks_md, # jenks low
           ymin = 0, ymax = 25, alpha = .25, fill = "blue")+
  annotate("rect", xmin=f_jnks_md, xmax=max(per_cap$rate), # jenks low
           ymin = 0, ymax = 25, alpha = .25, fill = "red")+
  labs(subtitle = "jenks outliers removed")+
  theme_classic()
```
<br><br>

##### Count and percent of counties with different abortion rate categories 

**Method**|**Low counties**|**Medium counties**|**High counties**
:---|:---|:---|:---|
**Standard deviation**|`r per_cap %>% filter(rate < ab_mn-ab_st_d) %>% count(rate) %>% summarise(sum(n))`   `r paste0("  /  ",round(100*(per_cap %>% filter(rate < ab_mn-ab_st_d) %>% count(rate) %>% summarise(sum(n))/460)),"%")`|`r per_cap %>% filter(between(rate, ab_mn-ab_st_d, ab_mn+ab_st_d)) %>% count(rate) %>% summarise(sum(n))`   `r paste0("  /  ",round(100*(per_cap %>% filter(between(rate, ab_mn-ab_st_d, ab_mn+ab_st_d)) %>% count(rate) %>% summarise(sum(n))/460)),"%")`|`r per_cap %>% filter(rate > ab_mn+ab_st_d) %>% count(rate) %>% summarise(sum(n))`   `r paste0("  /  ",round(100*(per_cap %>% filter(rate > ab_mn+ab_st_d) %>% count(rate) %>% summarise(sum(n))/460)),"%")`   
**Standard deviation with outliers removed**|`r per_cap %>% filter(rate < ab_mn_2-ab_st_d_2) %>% count(rate) %>% summarise(sum(n))`   `r paste0("  /  ",round(100*(per_cap %>% filter(rate < ab_mn_2-ab_st_d_2) %>% count(rate) %>% summarise(sum(n))/460)),"%")`|`r per_cap %>% filter(between(rate, ab_mn_2-ab_st_d_2, ab_mn_2+ab_st_d_2)) %>% count(rate) %>% summarise(sum(n))`  `r paste0("  /  ",round(100*(per_cap %>% filter(between(rate, ab_mn_2-ab_st_d_2, ab_mn_2+ab_st_d_2)) %>% count(rate) %>% summarise(sum(n))/460)),"%")`|`r per_cap %>% filter(rate > ab_mn_2+ab_st_d_2) %>% count(rate) %>% summarise(sum(n))`   `r paste0("  /  ",round(100*(per_cap %>% filter(rate > ab_mn_2+ab_st_d_2) %>% count(rate) %>% summarise(sum(n))/460)),"%")`
||
||
**Thirds**|`r per_cap %>% filter(rate < lw_trd) %>% count(rate) %>% summarise(sum(n))`   `r paste0("  /  ",round(100*(per_cap %>% filter(rate < lw_trd) %>% count(rate) %>% summarise(sum(n))/460)),"%")`|`r per_cap %>% filter(between(rate, lw_trd, md_trd)) %>% count(rate) %>% summarise(sum(n))`   `r paste0("  /  ",round(100*(per_cap %>% filter(between(rate, lw_trd, md_trd)) %>% count(rate) %>% summarise(sum(n))/460)),"%")`|`r per_cap %>% filter(rate > md_trd) %>% count(rate) %>% summarise(sum(n))`   `r paste0("  /  ",round(100*(per_cap %>% filter(rate > md_trd) %>% count(rate) %>% summarise(sum(n))/460)),"%")` 
**Thirds with outliers removed**|`r per_cap %>% filter(rate < f_lw_trd) %>% count(rate) %>% summarise(sum(n))`   `r paste0("  /  ",round(100*(per_cap %>% filter(rate < f_lw_trd) %>% count(rate) %>% summarise(sum(n))/460)),"%")`|`r per_cap %>% filter(between(rate, f_lw_trd, f_md_trd)) %>% count(rate) %>% summarise(sum(n))`   `r paste0("  /  ",round(100*(per_cap %>% filter(between(rate, f_lw_trd, f_md_trd)) %>% count(rate) %>% summarise(sum(n))/460)),"%")`|`r per_cap %>% filter(rate > f_md_trd) %>% count(rate) %>% summarise(sum(n))`   `r paste0("  /  ",round(100*(per_cap %>% filter(rate > f_md_trd) %>% count(rate) %>% summarise(sum(n))/460)),"%")`   
||
||
**Jenks natural breaks**|`r per_cap %>% filter(rate < res$classif$brks[2]) %>%  count(rate) %>% summarise(sum(n))`   `r paste0("  /  ",round(100*(per_cap %>% filter(rate < res$classif$brks[2]) %>%  count(rate) %>% summarise(sum(n))/460)),"%")`|`r per_cap %>% filter(between(rate, res$classif$brks[2], res$classif$brks[3])) %>% count(rate) %>% summarise(sum(n))`   `r paste0("  /  ",round(100*(per_cap %>% filter(between(rate, res$classif$brks[2], res$classif$brks[3])) %>% count(rate) %>% summarise(sum(n))/460)),"%")`|`r per_cap %>% filter(rate > res$classif$brks[3]) %>% count(rate) %>% summarise(sum(n))`   `r paste0("  /  ",round(100*(per_cap %>% filter(rate > res$classif$brks[3]) %>% count(rate) %>% summarise(sum(n))/460)),"%")` 
**Jenks natural breaks with outliers removed**|`r per_cap %>% filter(rate < f_res$classif$brks[2]) %>%  count(rate) %>% summarise(sum(n))`   `r paste0("  /  ",round(100*(per_cap %>% filter(rate < f_res$classif$brks[2]) %>%  count(rate) %>% summarise(sum(n))/460)),"%")`|`r per_cap %>% filter(between(rate, f_res$classif$brks[2], f_res$classif$brks[3])) %>% count(rate) %>% summarise(sum(n))`   `r paste0("  /  ",round(100*(per_cap %>% filter(between(rate, f_res$classif$brks[2], f_res$classif$brks[3])) %>% count(rate) %>% summarise(sum(n))/460)),"%")`|`r per_cap %>% filter(rate > f_res$classif$brks[3]) %>% count(rate) %>% summarise(sum(n))``r paste0("  /  ",round(100*(per_cap %>% filter(rate > f_res$classif$brks[3]) %>% count(rate) %>% summarise(sum(n))/460)),"%")`

***

### Visualizing the impact of different abortion rate categorizations

```{r load geometry, echo=T, include=TRUE}

#Add the geometry necessary for creating a map and then add the rankings to the data.

options(tigris_use_cache=TRUE)  # cache data

# import geometry for counties and GEOID
counties <- counties("IN", cb = T) %>% select(GEOID, geometry)

# make GEOID character in per_cap

per_cap$GEOID <- as.character(per_cap$GEOID)
# join county geometry with totals and population
per_cap <- left_join(per_cap, counties)


per_cap <- st_sf(per_cap)
```

```{r add rate rankings, echo=TRUE}

# Add rankings for each categorization method used above.

per_cap <- per_cap %>% 
  mutate(ab_sd_rank = 
           case_when(
             annual_co_med < ab_mn-ab_st_d ~ "la",
             between(annual_co_med, ab_mn-ab_st_d, ab_mn+ab_st_d) ~ "ma",
             annual_co_med > ab_mn+ab_st_d ~ "ha"),
         ab_f_sd_rank = 
          case_when(
            annual_co_med <= ab_mn_2-ab_st_d_2 ~ "la",
            between(annual_co_med, ab_mn_2-ab_st_d_2, ab_mn_2+ab_st_d_2) ~ "ma",
            annual_co_med >= ab_mn_2+ab_st_d_2 ~ "ha"),
         ab_trd_rank = 
          case_when(
            annual_co_med < lw_trd ~ "la",
            between(annual_co_med, lw_trd, md_trd) ~ "ma",
            annual_co_med > md_trd ~ "ha"),
        ab_f_trd_rank = 
          case_when(
            annual_co_med < f_lw_trd ~ "la",
            between(annual_co_med, f_lw_trd, f_md_trd) ~ "ma",
            annual_co_med > f_md_trd ~ "ha"),
        jnks =
          case_when(
            annual_co_med < jnks_lw ~ "la",
            between(annual_co_med, jnks_lw, jnks_md) ~ "ma",
            annual_co_med > jnks_md ~ "ha"),
        f_jnks =
          case_when(
            annual_co_med < f_jnks_lw ~ "la",
            between(annual_co_med, f_jnks_lw, f_jnks_md) ~ "ma",
            annual_co_med > f_jnks_md ~ "ha")
          ) 
```
<br>

##### Dividing the abortion rate using standard deviation.

<br>

```{r, echo=F, figures-sd-hist-map, fig.show="hold", out.width="50%"}

par(mar = c(3, 3, .1, .1))

ggplot(per_cap, aes(annual_co_med))+
  geom_histogram(bins=92)+
  geom_vline(xintercept = ab_mn, color = "blue")+ # mean
  geom_vline(xintercept = ab_median, color = "yellow")+ # median
  annotate("rect", xmin=0, xmax=ab_mn-ab_st_d,
           ymin = 0, ymax = 50, alpha = .2, fill = "green")+
  annotate("rect", xmin=ab_mn-ab_st_d, xmax=ab_st_d+ab_mn,
           ymin = 0, ymax = 50, alpha = .2, fill = "blue")+
  annotate("rect", xmin=ab_mn+ab_st_d, xmax=max(per_cap$rate),
           ymin = 0, ymax = 50, alpha = .2, fill = "red")+
  theme_classic()

ggplot()+
  geom_sf(data = per_cap %>% filter(year == 2021),
          aes(fill=ab_sd_rank),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Abortion rate",
                      labels = c(ha = "High",
                                 ma = "Medium",
                                 la = "Low"))+
  #labs(title = "standard deviation")+
  theme_void()


```

<br>

##### Dividing the abortion rate using standard deviation with outliers removed.


```{r, echo=F, figures-f-sd-hist-map, fig.show="hold", out.width="50%"}

par(mar = c(3, 3, .1, .1))

ggplot(per_cap, aes(annual_co_med))+
  geom_histogram(bins=92)+
  geom_vline(xintercept = ab_mn, color = "blue")+ # mean
  geom_vline(xintercept = ab_mn_2, color = "blue", linetype = "dashed")+ # filtered data mean
  geom_vline(xintercept = ab_median, color = "yellow")+ # median
  # annotate("rect", xmin=ab_mn-ab_st_d, xmax=ab_st_d+ab_mn, # show +- 1 sd
  #          ymin = 0, ymax = 25, alpha = .1, fill = "red")+
 annotate("rect", xmin=0, xmax=ab_mn_2-ab_st_d_2,
           ymin = 0, ymax = 50, alpha = .2, fill = "green")+
  annotate("rect", xmin=ab_mn_2-ab_st_d_2, xmax=ab_st_d_2+ab_mn_2,
           ymin = 0, ymax = 50, alpha = .2, fill = "blue")+
  annotate("rect", xmin=ab_mn_2+ab_st_d_2, xmax=max(per_cap$rate),
           ymin = 0, ymax = 50, alpha = .2, fill = "red")+
  theme_classic()

ggplot()+
  geom_sf(data = per_cap %>% filter(year == 2021),
          aes(fill=ab_f_sd_rank),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Abortion rate",
                      labels = c(ha = "High",
                                 ma = "Medium",
                                 la = "Low"))+
 # labs(title = "filtered \nstandard deviation")+
  theme_void()

```

<br>

##### Dividing the abortion rate into thirds.


```{r, echo=F, figures-trd-hist-map, fig.show="hold", out.width="50%"}

par(mar = c(3, 3, .1, .1))

ggplot(per_cap, aes(annual_co_med))+
  geom_histogram(bins=92)+
  geom_vline(xintercept = ab_mn, color = "blue")+ # mean
  geom_vline(xintercept = ab_mn_2, color = "blue", linetype = "dashed")+ # filtered data mean
  geom_vline(xintercept = ab_median, color = "yellow")+ # median
  # annotate("rect", xmin=ab_mn-ab_st_d, xmax=ab_st_d+ab_mn, # show +- 1 sd
  #          ymin = 0, ymax = 25, alpha = .1, fill = "red")+
  annotate("rect", xmin=0, xmax=lw_trd,
           ymin = 0, ymax = 50, alpha = .2, fill = "green")+
  annotate("rect", xmin=lw_trd, xmax=md_trd,
           ymin = 0, ymax = 50, alpha = .2, fill = "blue")+
  annotate("rect", xmin=md_trd, xmax=max(per_cap$rate),
           ymin = 0, ymax = 50, alpha = .2, fill = "red")+
  theme_classic()

ggplot()+
  geom_sf(data = per_cap %>% filter(year == 2021),
          aes(fill=ab_trd_rank),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Abortion rate",
                      labels = c(ha = "High",
                                 ma = "Medium",
                                 la = "Low"))+
 # labs(title = "thirds")+
  theme_void()

```

<br>

##### Dividing the abortion rate into thirds with outliers removed.

<br>
```{r, echo=F, figures-f_trd-hist-map, fig.show="hold", out.width="50%"}

par(mar = c(3, 3, .1, .1))

ggplot(per_cap, aes(annual_co_med))+
  geom_histogram(bins=92)+
  geom_vline(xintercept = ab_mn, color = "blue")+ # mean
  geom_vline(xintercept = ab_mn_2, color = "blue", linetype = "dashed")+ # filtered data mean
  geom_vline(xintercept = ab_median, color = "yellow")+ # median
  # annotate("rect", xmin=ab_mn-ab_st_d, xmax=ab_st_d+ab_mn, # show +- 1 sd
  #          ymin = 0, ymax = 25, alpha = .1, fill = "red")+
  annotate("rect", xmin=0, xmax=f_lw_trd,
           ymin = 0, ymax = 50, alpha = .2, fill = "green")+
  annotate("rect", xmin=f_lw_trd, xmax=f_md_trd,
           ymin = 0, ymax = 50, alpha = .2, fill = "blue")+
  annotate("rect", xmin=f_md_trd, xmax=max(per_cap$rate),
           ymin = 0, ymax = 50, alpha = .2, fill = "red")+
  theme_classic()

ggplot()+
  geom_sf(data = per_cap %>% filter(year == 2021),
          aes(fill=ab_f_trd_rank),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Abortion rate",
                      labels = c(ha = "High",
                                 ma = "Medium",
                                 la = "Low"))+
  #labs(title = "filtered thirds")+
  theme_void()

```

<br>

##### Dividing the abortion rate using jenks natural breaks.
<br>

```{r, echo=F, figures-jenks-hist-map, fig.show="hold", out.width="50%"}

par(mar = c(3, 3, .1, .1))

ggplot(per_cap, aes(annual_co_med))+
  geom_histogram(bins=92)+
  geom_vline(xintercept = ab_mn, color = "blue")+ # mean
  geom_vline(xintercept = ab_mn_2, color = "blue", linetype = "dashed")+ # filtered data mean
  geom_vline(xintercept = ab_median, color = "yellow")+ # median
  annotate("rect", xmin=0, xmax=jnks_lw, # jenks low
           ymin = 0, ymax = 50, alpha = .25, fill = "lime green")+
  annotate("rect", xmin=jnks_lw, xmax=jnks_md, # jenks low
           ymin = 0, ymax = 50, alpha = .25, fill = "blue")+
  annotate("rect", xmin=jnks_md, xmax=max(per_cap$rate),
           ymin = 0, ymax = 50, alpha = .25, fill = "red")+ # jenks low
  theme_classic()

ggplot()+
  geom_sf(data = per_cap %>% filter(year == 2021),
          aes(fill=jnks),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Abortion rate",
                      labels = c(ha = "High",
                                 ma = "Medium",
                                 la = "Low"))+
  #labs(title = "jenks")+
  theme_void()

```

<br>

##### Dividing the abortion rate using jenks natural breaks with outliers removed.
<br>

```{r, echo=F, figures-filtered_jenks-hist-map, fig.show="hold", out.width="50%"}

par(mar = c(3, 3, .1, .1))

ggplot(per_cap, aes(annual_co_med))+
  geom_histogram(bins=92)+
  geom_vline(xintercept = ab_mn, color = "blue")+ # mean
  geom_vline(xintercept = ab_mn_2, color = "blue", linetype = "dashed")+ # filtered data mean
  geom_vline(xintercept = ab_median, color = "yellow")+ # median
  annotate("rect", xmin=0, xmax=f_jnks_lw, # jenks low
           ymin = 0, ymax = 50, alpha = .25, fill = "lime green")+
  annotate("rect", xmin=f_jnks_lw, xmax=f_jnks_md, # jenks low
           ymin = 0, ymax = 50, alpha = .25, fill = "blue")+
  annotate("rect", xmin=f_jnks_md, xmax=max(per_cap$rate),
           ymin = 0, ymax = 50, alpha = .25, fill = "red")+ # jenks low
  theme_classic()

ggplot()+
  geom_sf(data = per_cap %>% filter(year == 2021),
          aes(fill=f_jnks),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Abortion rate",
                      labels = c(ha = "High",
                                 ma = "Medium",
                                 la = "Low"))+
  labs(title = "filtered jenks")+
  theme_void()

```

<br>
#### Comparing maps with abortion rates categories calculated using different methods 
<br>


```{r, echo=F, figures-unfiltered, fig.show="hold", out.width="33%"}

par(mar = c(3, 3, .1, .1))

ggplot()+
  geom_sf(data = per_cap %>% filter(year == 2021),
          aes(fill=ab_sd_rank),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Abortion rate",
                      labels = c(ha = "High",
                                 ma = "Medium",
                                 la = "Low"))+
  labs(title = "standard deviation")+
  theme_void()

ggplot()+
  geom_sf(data = per_cap %>% filter(year == 2021),
          aes(fill=ab_trd_rank),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Abortion rate",
                      labels = c(ha = "High",
                                 ma = "Medium",
                                 la = "Low"))+
  labs(title = "thirds")+
  theme_void()


ggplot()+
  geom_sf(data = per_cap %>% filter(year == 2021),
          aes(fill=jnks),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Abortion rate",
                      labels = c(ha = "High",
                                 ma = "Medium",
                                 la = "Low"))+
  labs(title = "jenks")+
  theme_void()


```


```{r, echo=F, figures-filtered, fig.show="hold", out.width="33%"}

par(mar = c(3, 3, .1, .1))

ggplot()+
  geom_sf(data = per_cap %>% filter(year == 2021),
          aes(fill=ab_f_sd_rank),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Abortion rate",
                      labels = c(ha = "High",
                                 ma = "Medium",
                                 la = "Low"))+
  labs(title = "filtered \nstandard deviation")+
  theme_void()

ggplot()+
  geom_sf(data = per_cap %>% filter(year == 2021),
          aes(fill=ab_f_trd_rank),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Abortion rate",
                      labels = c(ha = "High",
                                 ma = "Medium",
                                 la = "Low"))+
  labs(title = "filtered thirds")+
  theme_void()

ggplot()+
  geom_sf(data = per_cap %>% filter(year == 2021),
          aes(fill=f_jnks),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Abortion rate",
                      labels = c(ha = "High",
                                 ma = "Medium",
                                 la = "Low"))+
  labs(title = "filtered jenks")+
  theme_void()


```

<br><br>
The method to divide the rate into three parts that seems to best match the abortion rate data is to use standard deviation after removing outliers calculated using the 1.5 times the interquartile range method. <br><br>

***


### Median income data
```{r, echo=TRUE}
# load median income data
cache = TRUE

in_med <- 
  get_acs(
    geography = "county",
    year = 2021,
    state = "IN",
    variables = "B19013_001",output = "tidy",geometry = TRUE)
```

How are the median income data distributed? There are 92 counties represented in this data set.
```{r}
options(scipen=9999)
```

```{r fig.height = 4, echo=T}
ggplot(in_med, aes(estimate))+
  geom_histogram()

```

The data skew right with outliers on the right. The data will be divided with and without outliers to better see the outliers' impact on the location of our low, medium, and high dividing lines. 

To remove outlier rates, multipy the interquartile range (the distance between the 25th and 75th percentile) by 1.5 and filter rates that fall that amount below the first and that amount above the third quartile.

Increasing the bin size of the histogram will provide more detail about the frequency of rates. A solid blue lines represents the unfiltered mean, a dashed blue line represents the mean calculated after removing outliers. The yellow line is the median. Data within the shaded gray represent outliers.

```{r}

med_sd <- sd(in_med$estimate) # standard deviation
med_iqr <- iqr <- IQR(in_med$estimate) # interquartile range for median income 
med_mn <- mean(in_med$estimate) # mean 
med_med <- median(in_med$estimate) # median
med_iqr <- IQR(in_med$estimate)
med_qnt <- quantile(in_med$estimate)

# create dataframe without geometry column for easier calculations
in_med2 <- in_med

in_med2$geometry <- NULL

# create duplicate dataframe for calculations with outliers removed

in_med3 <- in_med2

in_med3 <- in_med3  %>% 
  filter(estimate >= quantile(in_med$estimate)[2]-med_iqr*1.5) %>%  
  # filters 1.5 interquartile range below quartile 1
  filter(estimate <= quantile(in_med$estimate)[2]+med_iqr*1.5)

f_med_mn <- mean(in_med3$estimate)
f_med_med <- median(in_med3$estimate)
f_med_sd <- sd(in_med3$estimate)
f_med_iqr <- IQR(in_med3$estimate)


```

```{r inc_outliers, echo=T, fig.height = 4, out.width="100%"}

ggplot(in_med, aes(estimate))+
  geom_histogram(bins=92)+
  geom_vline(xintercept = med_mn, color = "blue")+ # mean
  geom_vline(xintercept = med_med, color = "yellow")+ # median
  geom_vline(xintercept = f_med_mn, color = "blue", linetype = "dashed")+ # mean
  geom_vline(xintercept = med_med, color = "yellow", linetype="dashed")+
  annotate("rect", xmin=min(in_med$estimate), xmax=med_qnt[2] - (med_iqr*1.5),
           ymin = 0, ymax = 10, alpha = .15, fill = "gray")+
  annotate("rect", xmin=med_qnt[3] + (med_iqr*1.5), 
           xmax=max(in_med$estimate),
           ymin = 0, ymax = 10, alpha = .15, fill = "gray")+
  labs(subtitle = "Outliers in shaded gray area")+
  theme_classic()
```


#### Comparing the income data with and without outliers removed: <br>

**Category**|**Original<br>data**|**1.5 \*\IQR Outliers<br>removed**|
:---|:---|:---|
**Number of counties**|`r in_med2 %>% count(NAME) %>% summarise(sum(n))`|`r in_med3 %>% count(NAME) %>% summarise(sum(n))`
**Mean**|`r round(med_mn)`|`r round(f_med_mn)`
**Standard Deviation**| `r round(med_sd)`|`r round(f_med_sd)`
**Interquartile Range**| `r round(med_iqr)`|`r f_med_iqr`
**Range**|`r range(in_med2$estimate)`|`r range(in_med3$estimate)`
***

### Classifying income data into low, medium and high categories

<br>
#### Using standard deviation to divide the income range

Using standard deviation to divide the abortion rate into three classes would place all values located one standard deviation below the mean in the low category, rates within one standard deviation of the mean in the medium category and rates one standard deviation above the mean in the high category. 


```{r inc_stnd_dev, echo=TRUE, fig.height=4, out.width="50%"}
ggplot(in_med, aes(estimate))+
  geom_histogram(bins=92)+
  geom_vline(xintercept = med_mn, color = "blue")+ # mean
  geom_vline(xintercept = med_med, color = "yellow")+ # median
  annotate("rect", xmin=min(in_med$estimate), xmax=med_mn-med_sd,
           ymin = 0, ymax = 10, alpha = .2, fill = "green")+
  annotate("rect", xmin=med_mn-med_sd, xmax=med_mn+med_sd,
           ymin = 0, ymax = 10, alpha = .2, fill = "blue")+
  annotate("rect", xmin=med_mn+med_sd, xmax=max(in_med$estimate),
           ymin = 0, ymax = 10, alpha = .2, fill = "red")+
  labs(subtitle = "standard deviation")+
  theme_classic()

ggplot(in_med, aes(estimate))+
  geom_histogram(bins=92)+
  geom_vline(xintercept = f_med_mn, color = "blue")+ # mean
  geom_vline(xintercept = f_med_med, color = "yellow")+ # median
  annotate("rect", xmin=min(in_med$estimate), xmax=f_med_mn-f_med_sd,
           ymin = 0, ymax = 10, alpha = .2, fill = "green")+
  annotate("rect", xmin=f_med_mn-f_med_sd, xmax=f_med_mn+f_med_sd,
           ymin = 0, ymax = 10, alpha = .2, fill = "blue")+
  annotate("rect", xmin=f_med_mn+f_med_sd, xmax=max(in_med$estimate),
           ymin = 0, ymax = 10, alpha = .2, fill = "red")+
  labs(subtitle = "standard deviation, outliers removed")+
  theme_classic()
```

##### Count of counties by different income rate category classification methods 

**Method**|**Low Counties**|**Medium Counties**|**High Counties**
:---|:---|:---|:---|
**Standard deviation**|`r in_med2 %>% filter(estimate < med_mn-med_sd) %>% count(estimate) %>% summarise(sum(n))` |`r in_med2 %>% filter(between(estimate, med_mn-med_sd, med_mn+med_sd)) %>% count(estimate) %>% summarise(sum(n))`|`r in_med2 %>% filter(estimate > med_mn+med_sd) %>% count(estimate) %>% summarise(sum(n))` 
**Standard deviation with outliers removed**|`r in_med2 %>% filter(estimate < f_med_mn-f_med_sd) %>% count(estimate) %>% summarise(sum(n))`|`r in_med2 %>% filter(between(estimate, f_med_mn-f_med_sd, f_med_mn+f_med_sd)) %>% count(estimate) %>% summarise(sum(n))`|`r in_med2 %>% filter(estimate > f_med_mn+f_med_sd) %>% count(estimate) %>% summarise(sum(n))`  
***

#### Dividing the income range into equal thirds

<br>
An alternative approach to using standard deviation to categorize low, medium and high rates would be to divide the range of the rate - the amount between the minimum and maximum values - into thirds.


```{r calculate_med_thirds, echo=T}
# determine range of rate
med_og_inc <- range(in_med2$estimate)[2]-range(in_med2$estimate)[1]

# assign lower third line and middle third line to object
med_lw_trd <- med_og_inc * .333                            
med_md_trd <- med_og_inc * (2*.333 )

# repeat for data with 1.5*IQR outliers removed

f_inc <- range(in_med3$estimate)[2]-range(in_med3$estimate)[1]

f_med_lw_trd <-  f_inc *.333
f_med_md_trd <- f_inc * (2*.333)

```


```{r, med_trd_hist, fig.height = 4, echo=FALSE, out.width="50%"}
ggplot(in_med, aes(estimate))+
  geom_histogram(bins=92)+
  geom_vline(xintercept = med_mn, color = "blue")+ # mean
  geom_vline(xintercept = med_med, color = "yellow")+ # median
  annotate("rect", xmin=min(in_med2$estimate), xmax=min(in_med2$estimate)+med_lw_trd,
           ymin = 0, ymax = 10, alpha = .2, fill = "green")+
  annotate("rect", xmin=min(in_med2$estimate)+med_lw_trd, 
           xmax=min(in_med2$estimate)+med_md_trd,
           ymin = 0, ymax = 10, alpha = .2, fill = "blue")+
  annotate("rect", xmin=min(in_med2$estimate)+med_md_trd, 
           xmax=max(in_med2$estimate),
           ymin = 0, ymax = 10, alpha = .2, fill = "red")+
  labs(subtitle = "thirds")+
  theme_classic()

ggplot(in_med, aes(estimate))+
  geom_histogram(bins=92)+
  geom_vline(xintercept = med_mn, color = "blue")+ # mean
  geom_vline(xintercept = f_med_mn, color = "blue", linetype = "dashed")+ # filtered mean
  geom_vline(xintercept = med_med, color = "yellow")+ # median
  annotate("rect", xmin=min(in_med2$estimate), # filtered low third
          xmax=min(in_med2$estimate)+f_med_lw_trd,
          ymin = 0, ymax = 10, alpha = .2, fill = "green")+
  annotate("rect", xmin=min(in_med2$estimate)+f_med_lw_trd,  # filterd middle third
           xmax=min(in_med2$estimate)+f_med_md_trd,
           ymin = 0, ymax = 10, alpha = .2, fill = "blue")+ # filtered top third
  annotate("rect", xmin=min(in_med2$estimate)+f_med_md_trd, 
           xmax=max(in_med2$estimate),
           ymin = 0, ymax = 10, alpha = .2, fill = "red")+
  labs(subtitle = "thirds, outliers removed")+
  theme_classic()
```

##### Count of counties by different income rate category classification methods 

**Method**|**Low Counties**|**Medium Counties**|**High Counties**
:---|:---|:---|:---|
**Standard deviation**|`r in_med2 %>% filter(estimate < med_mn-med_sd) %>% count(estimate) %>% summarise(sum(n))` |`r in_med2 %>% filter(between(estimate, med_mn-med_sd, med_mn+med_sd)) %>% count(estimate) %>% summarise(sum(n))`|`r in_med2 %>% filter(estimate > med_mn+med_sd) %>% count(estimate) %>% summarise(sum(n))` 
**Standard deviation with outliers removed**|`r in_med2 %>% filter(estimate < f_med_mn-f_med_sd) %>% count(estimate) %>% summarise(sum(n))`|`r in_med2 %>% filter(between(estimate, f_med_mn-f_med_sd, f_med_mn+f_med_sd)) %>% count(estimate) %>% summarise(sum(n))`|`r in_med2 %>% filter(estimate > f_med_mn+f_med_sd) %>% count(estimate) %>% summarise(sum(n))`  
|||
|||
**Thirds**| `r in_med2 %>% filter(estimate < min(in_med2$estimate+med_lw_trd)) %>% count(estimate) %>% summarise(sum(n))`|`r in_med2 %>% filter(between(estimate, min(in_med2$estimate)+med_lw_trd, min(in_med2$estimate)+med_md_trd)) %>% count(estimate) %>% summarise(sum(n))`|`r in_med2 %>% filter(estimate > min(in_med2$estimate)+med_md_trd) %>% count(estimate) %>% summarise(sum(n))`
**Thirds with outliers removed**| `r in_med2 %>% filter(estimate < min(in_med2$estimate+f_med_lw_trd)) %>% count(estimate) %>% summarise(sum(n))`|`r in_med2 %>% filter(between(estimate, min(in_med2$estimate)+f_med_lw_trd, min(in_med2$estimate)+f_med_md_trd)) %>% count(estimate) %>% summarise(sum(n))`|`r in_med2 %>% filter(estimate > min(in_med2$estimate)+f_med_md_trd) %>% count(estimate) %>% summarise(sum(n))`
***

#### Dividing the income range using Jenks

Another way to divde the data is use the [jenks natural breaks](http://wiki.gis.com/wiki/index.php/Jenks_Natural_Breaks_Classification) method.  

```{r, inc_jenks_function, fig.show="hide", echo=TRUE}

# load function for jenks breaks
# from: http://cainarchaeology.weebly.com/r-function-for-plotting-jenks-natural-breaks-classification.html

plotJenks <- function(data, n=3, brks.cex=0.70, top.margin=10, dist=5){
  df <- data.frame(sorted.values=sort(data, decreasing=TRUE))
  Jclassif <- classIntervals(df$sorted.values, n, style = "jenks") #requires the 'classInt' package
  test <- jenks.tests(Jclassif) #requires the 'classInt' package
  df$class <- cut(df$sorted.values, unique(Jclassif$brks), labels=FALSE, include.lowest=TRUE) #the function unique() is used to remove non-unique breaks, should the latter be produced. This is done because the cut() function cannot break the values into classes if non-unique breaks are provided
  if(length(Jclassif$brks)!=length(unique(Jclassif$brks))){
    info <- ("The method has produced non-unique breaks, which have been removed. Please, check '...$classif$brks'")
  } else {info <- ("The method did not produce non-unique breaks.")}
  loop.res <- numeric(nrow(df))
  i <- 1
  repeat{
    i <- i+1
    loop.class <- classIntervals(df$sorted.values, i, style = "jenks")
    loop.test <- jenks.tests(loop.class)
    loop.res[i] <- loop.test[[2]]
    if(loop.res[i]>0.9999){
      break
    }
  }
  max.GoF.brks <- which.max(loop.res)
  plot(x=df$sorted.values, y=c(1:nrow(df)), type="b", main=paste0("Jenks natural breaks optimization; number of classes: ", n), sub=paste0("Goodness of Fit: ", round(test[[2]],4), ". Max GoF (", round(max(loop.res),4), ") with classes:", max.GoF.brks), ylim =c(0, nrow(df)+top.margin), cex=0.75, cex.main=0.95, cex.sub=0.7, ylab="observation index", xlab="value (increasing order)")
  abline(v=Jclassif$brks, lty=3, col="red")
  text(x=Jclassif$brks, y= max(nrow(df)) + dist, labels=sort(round(Jclassif$brks, 2)), cex=brks.cex, srt=90)
  results <- list("info"=info, "classif" = Jclassif, "breaks.max.GoF"=max.GoF.brks, "class.data" = df)
  return(results)
}

```

```{r include=FALSE, inc_jenks_breaks}

# calculate natural breaks for non-filtered data

inc_res <- plotJenks(data = in_med2$estimate, n=3, brks.cex = .7, top.margin = 10, dist = 5)

# assign break values 

inc_jnks_lw <- inc_res$classif$brks[2]
inc_jnks_md <- inc_res$classif$brks[3]

# calculate natural breaks for filtered data

f_inc_res <- plotJenks(data = in_med3$estimate, n=3, brks.cex = .7, top.margin = 10, dist = 5)

# assign break values for filtered data

f_inc_jnks_lw <- f_inc_res$classif$brks[2]
f_inc_jnks_md <- f_inc_res$classif$brks[3]

```

```{r inc_jenks_plot, echo=FALSE, fig.height= 4, out.width="50%"}
ggplot(in_med, aes(estimate))+
  geom_histogram(bins=92)+
  annotate("rect", xmin=min(in_med2$estimate), xmax=inc_jnks_lw, # jenks low
           ymin = 0, ymax = 25, alpha = .25, fill = "green")+
  annotate("rect", xmin=inc_jnks_lw, xmax=inc_jnks_md, # jenks low
           ymin = 0, ymax = 25, alpha = .25, fill = "blue")+
  annotate("rect", xmin=inc_jnks_md, xmax=max(in_med2$estimate), # jenks low
           ymin = 0, ymax = 25, alpha = .25, fill = "red")+
  labs(subtitle = "jenks")+
  theme_classic()

ggplot(in_med, aes(estimate))+
  geom_histogram(bins=92)+
  annotate("rect", xmin=min(in_med2$estimate), xmax=f_inc_jnks_lw, # jenks low
           ymin = 0, ymax = 25, alpha = .25, fill = "green")+
  annotate("rect", xmin=f_inc_jnks_lw, xmax=f_inc_jnks_md, # jenks low
           ymin = 0, ymax = 25, alpha = .25, fill = "blue")+
  annotate("rect", xmin=f_inc_jnks_md, xmax=max(in_med2$estimate), # jenks low
           ymin = 0, ymax = 25, alpha = .25, fill = "red")+
  labs(subtitle = "jenks outliers removed")+
  theme_classic()
```

##### Count and percent of counties by different income rate category classification methods 

**Method**|**Low Counties**|**Medium Counties**|**High Counties**
:---|:---|:---|:---|
**Standard deviation**|`r in_med2 %>% filter(estimate < med_mn-med_sd) %>% count(estimate) %>% summarise(sum(n))` `r paste0("  /  ",round(100*in_med2 %>% filter(estimate < med_mn-med_sd) %>% count(estimate) %>% summarise(sum(n))/92),"%")` |`r in_med2 %>% filter(between(estimate, med_mn-med_sd, med_mn+med_sd)) %>% count(estimate) %>% summarise(sum(n))` `r paste0("  /  ",round(100*in_med2 %>% filter(between(estimate, med_mn-med_sd, med_mn+med_sd)) %>% count(estimate) %>% summarise(sum(n))/92),"%")`|`r in_med2 %>% filter(estimate > med_mn+med_sd) %>% count(estimate) %>% summarise(sum(n))` `r paste0("  /  ", round(100*in_med2 %>% filter(estimate > med_mn+med_sd) %>% count(estimate) %>% summarise(sum(n))/92),"%")`
**Standard deviation with outliers removed**|`r in_med2 %>% filter(estimate < f_med_mn-f_med_sd) %>% count(estimate) %>% summarise(sum(n))``r paste0("  /  ", round(100*in_med2 %>% filter(estimate < f_med_mn-f_med_sd) %>% count(estimate) %>% summarise(sum(n))/92),"%")`|`r in_med2 %>% filter(between(estimate, f_med_mn-f_med_sd, f_med_mn+f_med_sd)) %>% count(estimate) %>% summarise(sum(n))``r paste0("  /  ", round(100*in_med2 %>% filter(between(estimate, f_med_mn-f_med_sd, f_med_mn+f_med_sd)) %>% count(estimate) %>% summarise(sum(n))/92),"%")`|`r in_med2 %>% filter(estimate > f_med_mn+f_med_sd) %>% count(estimate) %>% summarise(sum(n))` `r paste0("  /  ", round(100*in_med2 %>% filter(estimate > f_med_mn+f_med_sd) %>% count(estimate) %>% summarise(sum(n))/92),"%")` 
|||
|||
**Thirds**| `r in_med2 %>% filter(estimate < min(in_med2$estimate+med_lw_trd)) %>% count(estimate) %>% summarise(sum(n))``r paste0("  /  ", round(100*in_med2 %>% filter(estimate < min(in_med2$estimate+med_lw_trd)) %>% count(estimate) %>% summarise(sum(n))/92),"%")`|`r in_med2 %>% filter(between(estimate, min(in_med2$estimate)+med_lw_trd, min(in_med2$estimate)+med_md_trd)) %>% count(estimate) %>% summarise(sum(n))` `r paste0("  /  ", round(100*in_med2 %>% filter(between(estimate, min(in_med2$estimate)+med_lw_trd, min(in_med2$estimate)+med_md_trd)) %>% count(estimate) %>% summarise(sum(n))/92),"%")`|`r in_med2 %>% filter(estimate > min(in_med2$estimate)+med_md_trd) %>% count(estimate) %>% summarise(sum(n))` `r paste0("  /  ", round(100*in_med2 %>% filter(estimate > min(in_med2$estimate)+med_md_trd) %>% count(estimate) %>% summarise(sum(n))/92),"%")`
**Thirds with outliers removed**| `r in_med2 %>% filter(estimate < min(in_med2$estimate+f_med_lw_trd)) %>% count(estimate) %>% summarise(sum(n))``r paste0("  /  ", round(100*in_med2 %>% filter(estimate < min(in_med2$estimate+f_med_lw_trd)) %>% count(estimate) %>% summarise(sum(n))/92),"%")`|`r in_med2 %>% filter(between(estimate, min(in_med2$estimate)+f_med_lw_trd, min(in_med2$estimate)+f_med_md_trd)) %>% count(estimate) %>% summarise(sum(n))` `r paste0("  /  ", round(100*in_med2 %>% filter(between(estimate, min(in_med2$estimate)+f_med_lw_trd, min(in_med2$estimate)+f_med_md_trd)) %>% count(estimate) %>% summarise(sum(n))/92),"%")`|`r in_med2 %>% filter(estimate > min(in_med2$estimate)+f_med_md_trd) %>% count(estimate) %>% summarise(sum(n))``r paste0("  /  ", round(100*in_med2 %>% filter(estimate > min(in_med2$estimate)+f_med_md_trd) %>% count(estimate) %>% summarise(sum(n))/92),"%")`
|||
|||
**Jenks**|`r in_med2 %>% filter(estimate < inc_jnks_lw) %>% count(estimate) %>% summarise(sum(n))``r paste0("  /  ", round(100*in_med2 %>% filter(estimate < inc_jnks_lw) %>% count(estimate) %>% summarise(sum(n))/92),"%")`|`r in_med2 %>% filter(between(estimate, inc_jnks_lw,inc_jnks_md)) %>% count(estimate) %>% summarise(sum(n))``r paste0("  /  ", round(100*in_med2 %>% filter(between(estimate, inc_jnks_lw,inc_jnks_md)) %>% count(estimate) %>% summarise(sum(n))/92),"%")`|`r in_med2 %>% filter(estimate > inc_jnks_md) %>% count(estimate) %>% summarise(sum(n))` `r paste0("  /  ", round(100*in_med2 %>% filter(estimate > inc_jnks_md) %>% count(estimate) %>% summarise(sum(n))/92),"%")`
**Jenks with outliers removed**|`r in_med2 %>% filter(estimate < f_inc_jnks_lw) %>% count(estimate) %>% summarise(sum(n))``r paste0("  /  ", round(100*in_med2 %>% filter(estimate < f_inc_jnks_lw) %>% count(estimate) %>% summarise(sum(n))/92),"%")`|`r in_med2 %>% filter(between(estimate, f_inc_jnks_lw, f_inc_jnks_md)) %>% count(estimate) %>% summarise(sum(n))``r paste0("  /  ", round(100*in_med2 %>% filter(between(estimate, f_inc_jnks_lw, f_inc_jnks_md)) %>% count(estimate) %>% summarise(sum(n))/92),"%")`|`r in_med3 %>% filter(estimate > f_inc_jnks_md) %>% count(estimate) %>% summarise(sum(n))``r paste0("  /  ", round(100*in_med3 %>% filter(estimate > f_inc_jnks_md) %>% count(estimate) %>% summarise(sum(n))/92),"%")`
***

### Visualizing the impact of different income categorizations

Visualizing how the map is impacted by the method used to divide the income rate. 

```{r add income rankings, echo=TRUE}

# Because the median income data was imported from tidycensus the necessary geometry data for mapping is present, but the rankings still need to be added.

in_med <- in_med %>% 
  mutate(sd_rank = 
           case_when(
             estimate < med_mn-med_sd ~ "li",
             between(estimate, med_mn-med_sd, med_mn+med_sd) ~ "mi",
             estimate > med_mn+med_sd ~ "hi"),
         f_sd_rank = 
           case_when(
          estimate < f_med_mn-f_med_sd ~ "li",
             between(estimate, f_med_mn-f_med_sd, f_med_mn+f_med_sd) ~ "mi",
             estimate > f_med_mn+f_med_sd ~ "hi"),
         trd_rank = 
          case_when(
            estimate < min(in_med$estimate) + med_lw_trd ~ "li",
            between(estimate, min(in_med$estimate) + med_lw_trd, min(in_med$estimate) + 2*med_lw_trd) ~ "mi",
            estimate > min(in_med$estimate) + 2*med_lw_trd ~ "hi"),
        f_trd_rank = 
          case_when(
            estimate < min(in_med$estimate) + f_med_lw_trd ~ "li",
            between(estimate, min(in_med$estimate) + f_med_lw_trd, min(in_med$estimate) + 2*f_med_lw_trd) ~ "mi",
            estimate > min(in_med$estimate) + 2*f_med_lw_trd ~ "hi"),
        in_jnks = 
          case_when(
            estimate < inc_jnks_lw ~ "li",
            between(estimate, inc_jnks_lw, inc_jnks_md) ~ "mi",
            estimate > inc_jnks_md ~ "hi"
          ),
        f_in_jnks = 
          case_when(
            estimate < f_inc_jnks_lw ~ "li",
            between(estimate, f_inc_jnks_lw, f_inc_jnks_md) ~ "mi",
            estimate > f_inc_jnks_md ~ "hi"
          ))
```
<br>

##### Dividing the income rate using standard deviation.
<br>
```{r, echo=F, figures-sd_inc, fig.show="hold", out.width="50%"}

par(mar = c(3, 3, .1, .1))

ggplot(in_med, aes(estimate))+
  geom_histogram(bins=92)+
  geom_vline(xintercept = med_mn, color = "blue")+ # mean
  geom_vline(xintercept = med_med, color = "yellow")+ # median
  annotate("rect", xmin=min(in_med$estimate), xmax=med_mn-med_sd,
           ymin = 0, ymax = 10, alpha = .2, fill = "green")+
  annotate("rect", xmin=med_mn-med_sd, xmax=med_mn+med_sd,
           ymin = 0, ymax = 10, alpha = .2, fill = "blue")+
  annotate("rect", xmin=med_mn+med_sd, xmax=max(in_med$estimate),
           ymin = 0, ymax = 10, alpha = .2, fill = "red")+
  theme_classic()

ggplot()+
  geom_sf(data = in_med,
          aes(fill=sd_rank),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Median income",
                      labels = c(hi = "High",
                                 mi = "Medium",
                                 li = "Low"))+
 # labs(title = "standard deviation")+
  theme_void()
```
<br>

##### Dividing the income rate using standard deviation with outliers removed.
<br>
```{r, echo=F, figures-filtered_sd_inc, fig.show="hold", out.width="50%"}

par(mar = c(3, 3, .1, .1))

ggplot(in_med, aes(estimate))+
  geom_histogram(bins=92)+
  annotate("rect", xmin=min(in_med$estimate), xmax=f_med_mn-f_med_sd,
           ymin = 0, ymax = 10, alpha = .2, fill = "green")+
  annotate("rect", xmin=f_med_mn-f_med_sd, xmax=f_med_mn+f_med_sd,
           ymin = 0, ymax = 10, alpha = .2, fill = "blue")+
  annotate("rect", xmin=f_med_mn+f_med_sd, xmax=max(in_med$estimate),
           ymin = 0, ymax = 10, alpha = .2, fill = "red")+
  theme_classic()

ggplot()+
  geom_sf(data = in_med,
          aes(fill=f_sd_rank),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Median income",
                      labels = c(hi = "High",
                                 mi = "Medium",
                                 li = "Low"))+
  labs(title = "filtered \nstandard deviation")+
  theme_void()
```
<br>

##### Dividing the income rate into thirds.
<br>
```{r, echo=F, figures-thirds_inc, fig.show="hold", out.width="50%"}

par(mar = c(3, 3, .1, .1))

ggplot(in_med, aes(estimate))+
  geom_histogram(bins=92)+
  annotate("rect", xmin=min(in_med2$estimate), # filtered low third
          xmax=min(in_med2$estimate)+med_lw_trd,
          ymin = 0, ymax = 10, alpha = .2, fill = "green")+
  annotate("rect", xmin=min(in_med2$estimate)+med_lw_trd,  # filterd middle third
           xmax=min(in_med2$estimate)+med_md_trd,
           ymin = 0, ymax = 10, alpha = .2, fill = "blue")+ # filtered top third
  annotate("rect", xmin=min(in_med2$estimate)+med_md_trd, 
           xmax=max(in_med2$estimate),
           ymin = 0, ymax = 10, alpha = .2, fill = "red")+
  theme_classic()

ggplot()+
  geom_sf(data = in_med,
          aes(fill=trd_rank),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Median income",
                      labels = c(hi = "High",
                                 mi = "Medium",
                                 li = "Low"))+
  labs(title = "thirds")+
  theme_void()
```
<br>

##### Dividing the income rate into thirds with outliers removed.
<br>
```{r, echo=F, figures-filtered_thirds_inc, fig.show="hold", out.width="50%"}

par(mar = c(3, 3, .1, .1))

ggplot(in_med, aes(estimate))+
  geom_histogram(bins=92)+
  annotate("rect", xmin=min(in_med2$estimate), # filtered low third
          xmax=min(in_med2$estimate)+f_med_lw_trd,
          ymin = 0, ymax = 10, alpha = .2, fill = "green")+
  annotate("rect", xmin=min(in_med2$estimate)+f_med_lw_trd,  # filterd middle third
           xmax=min(in_med2$estimate)+f_med_md_trd,
           ymin = 0, ymax = 10, alpha = .2, fill = "blue")+ # filtered top third
  annotate("rect", xmin=min(in_med2$estimate)+f_med_md_trd, 
           xmax=max(in_med2$estimate),
           ymin = 0, ymax = 10, alpha = .2, fill = "red")+
  theme_classic()

ggplot()+
  geom_sf(data = in_med,
          aes(fill=f_trd_rank),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Median income",
                      labels = c(hi = "High",
                                 mi = "Medium",
                                 li = "Low"))+
  labs(title = "filtered thirds")+
  theme_void()
```
<br>

##### Dividing the rate into thirds using jenks natural breaks.

```{r, echo=F, figures-jenks_inc, fig.show="hold", out.width="50%"}

par(mar = c(3, 3, .1, .1))

ggplot(in_med, aes(estimate))+
  geom_histogram(bins=92)+
  annotate("rect", xmin=min(in_med2$estimate), # filtered low third
          xmax=inc_jnks_lw,
          ymin = 0, ymax = 10, alpha = .2, fill = "green")+
  annotate("rect", xmin=inc_jnks_lw,  # filterd middle third
           xmax=inc_jnks_md,
           ymin = 0, ymax = 10, alpha = .2, fill = "blue")+ # filtered top third
  annotate("rect", xmin=inc_jnks_md, 
           xmax=max(in_med2$estimate),
           ymin = 0, ymax = 10, alpha = .2, fill = "red")+
  theme_classic()

ggplot()+
  geom_sf(data = in_med,
          aes(fill=in_jnks),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Median income",
                      labels = c(hi = "High",
                                 mi = "Medium",
                                 li = "Low"))+
 # labs(title = "filtered thirds")+
  theme_void()
```

##### Dividing the rate into thirds using jenks natural breaks with outliers removed.

```{r, echo=F, figures-f_jenks_inc, fig.show="hold", out.width="50%"}

par(mar = c(3, 3, .1, .1))

ggplot(in_med, aes(estimate))+
  geom_histogram(bins=92)+
  annotate("rect", xmin=min(in_med2$estimate), # filtered low third
          xmax=f_inc_jnks_lw,
          ymin = 0, ymax = 10, alpha = .2, fill = "green")+
  annotate("rect", xmin=f_inc_jnks_lw,  # filterd middle third
           xmax=f_inc_jnks_md,
           ymin = 0, ymax = 10, alpha = .2, fill = "blue")+ # filtered top third
  annotate("rect", xmin=f_inc_jnks_md, 
           xmax=max(in_med2$estimate),
           ymin = 0, ymax = 10, alpha = .2, fill = "red")+
  theme_classic()

ggplot()+
  geom_sf(data = in_med,
          aes(fill=f_in_jnks),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Median income",
                      labels = c(hi = "High",
                                 mi = "Medium",
                                 li = "Low"))+
 # labs(title = "filtered jenks")+
  theme_void()
```

***

#### Comparing the maps of income rates side by side

<br>

##### Raw data

```{r, echo=F, maps-inc_raw, fig.show="hold", out.width="33.3%"}

par(mar = c(3, 3, .1, .1))

ggplot()+
  geom_sf(data = in_med,
          aes(fill=sd_rank),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Median income",
                      labels = c(hi = "High",
                                 mi = "Medium",
                                 li = "Low"))+
  labs(title = "standard deviation")+
  theme_void()

ggplot()+
  geom_sf(data = in_med,
          aes(fill=trd_rank),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Median income",
                      labels = c(hi = "High",
                                 mi = "Medium",
                                 li = "Low"))+
  labs(title = "thirds")+
  theme_void()

ggplot()+
  geom_sf(data = in_med,
          aes(fill=in_jnks),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Median income",
                      labels = c(hi = "High",
                                 mi = "Medium",
                                 li = "Low"))+
  labs(title = "Jenks")+
  theme_void()


```

##### Data with outliers removed 

```{r, echo=F, maps-inc_filtered, fig.show="hold", out.width="33.3%"}

par(mar = c(3, 3, .1, .1))

ggplot()+
  geom_sf(data = in_med,
          aes(fill=f_sd_rank),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Median income",
                      labels = c(hi = "High",
                                 mi = "Medium",
                                 li = "Low"))+
 labs(title = "standard deviation")+
  theme_void()

ggplot()+
  geom_sf(data = in_med,
          aes(fill=f_trd_rank),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Median income",
                      labels = c(hi = "High",
                                 mi = "Medium",
                                 li = "Low"))+
  labs(title = "thirds")+
  theme_void()

ggplot()+
  geom_sf(data = in_med,
          aes(fill=f_in_jnks),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = T)+
  scale_fill_discrete(name = "Median income",
                      labels = c(hi = "High",
                                 mi = "Medium",
                                 li = "Low"))+
  labs(title = "jenks")+
  theme_void()

```


<br>
Dividing the income rate using Jenks natural breaks yields the best results. 

***

### The bivariate map

The data for abortion rate and the data for median income need to be combined. 

```{r, remove_geometry for now, echo=F}
per_cap$geometry <- NULL
```


```{r, join per_cap, in_med, echo=T}
inc_ab <- per_cap %>% 
  left_join(in_med, per_cap, by = "GEOID") %>% 
    select(-c(variable, NAME))

# add column for joint ranking

inc_ab <- inc_ab %>% mutate(rank = paste0(ab_f_sd_rank, in_jnks),
                            .after = Name)
```

Prepare a color scheme: Josh Stevens posted a helpful [explanation](https://www.joshuastevens.net/cartography/make-a-bivariate-choropleth-map/) about creating a bivariate map color scheme. This map uses one of his suggested palettes. Similarly, Timo Grossenbacher's [post](https://timogrossenbacher.ch/2019/04/bivariate-maps-with-ggplot2-and-sf/) about creating a bivariate map in R influenced the process below. 

To keep things straight it helps to visualize 3 x 3 grid with abortion increasing from left to right in three stages and income increasing from bottom to top. Each square gets a code to make it easier to keep things straight.

      # a3 b3 c3
      # a2 b2 c2
      # a1 b1 c1

Each location on the grid will be assigned a value and a corresponding color. The values for low, medium and high were assigned for each data set during the steps above but they'll need to be combined into one code and then assigned a color. 

First, assign the colors.

```{r create color assignments, echo=T, class.source = "fold-show" }

# colors 
col <- c(
  "#e8e8e8",  # a1  low abortion - low income       a1: la-li           
  "#b5c0da",  # b1 medium abortion - low income     b1: ma-li     
  "#6c83b5",  # c1 high abortion - low income       c1: ha-li    
  "#b8d6be",  # a2 low abortion - medium income     a2: la-mi
  "#90b2b3",  # b2 medium abortion - medium income  b2: ma-mi
  "#567994",  # c2 high abortion - medium income    c2: ha-mi
  "#73ae80",  # a3 low abortion - high income       a3: la-hi
  "#5a9178",  # b3 medium abortion - high income    b3: ma-hi
  "#2a5a5b")  # c3 high abortion - high income      c3: ha-hi

# positions of matrix
col_pos <- c(
  "a1",
  "b1",
  "c1",
  "a2",
  "b2",
  "c2",
  "a3",
  "b3",
  "c3")

# a description for easy reference 

desc <- c("low abortion - low income",        #a1
          "medium abortion - low income",     #b1
          "high abortion - low income",       #c1
          "low abortion - medium income",     #a2
          "medium abortion - medium income",  #b2
          "high abortion - medium income",    #c2
          "low abortion - high income",       #a3
          "medium abortion - high income",    #b3
          "high abortion - high income")      #c3

# a two category code to assign to categories (abortion rate and median income)

rank <- c("lali", "mali", "hali", "lami", "mami", "hami", "lahi", "mahi",
          "hahi")

# combine into tibble

biv_col <- tibble(pos = col_pos, color = col, rank = rank, desc=desc)

```

Join the dataframe with the color and rank categories to the dataframe with the ranked abortion rate and median income data. 
```{r, echo=T}
# join biv_color to inc_ab dataframe ####
# using standard deviation 1.5*IQR abortion rate

biv <- left_join(inc_ab, biv_col, by = "rank")

sf_biv <- st_sf(biv)
```


Create the legend. 

```{r, echo=T, class.source = "fold-show"}
# create legend: ####
legend <- 
  
biv_col %>% mutate(
  x = str_sub(pos, start = 1L, end = 1L),
  y = str_sub(pos, start = 2L, end = 2L)
) %>% 
ggplot()+
  geom_tile(
    aes(x, y,
      fill = color)
  ) +
  scale_fill_identity() +
  labs(
    x = paste0("Increasing abortion  ", "\U2192"),
    y = paste0("Increasing income    ", "\U2192")
  )+
  theme_void()+
  theme(
    axis.title.x = element_text(size = 8,
                                hjust = .8),
    axis.title.y = element_text(size = 8,
                                vjust = 0,
                                hjust = 1,
                                angle = 90),
    axis.text = element_blank()
  )+
  coord_fixed(ratio = 1:1)
```


```{r}
# titles and captions ####
title <- "Indiana county abortion rate and median household income"
s_title <- "Average abortion rate per 1,000 females of childbearing age and median household income from 2017 to 2021.<br>"
caption <- "<br><br>**Abortion data**: in.gov/health/vital-records/vital-statistics/terminated-pregnancy-reports/ <br>
**Income data**: 5 year American Community Survey: 2021 Median household income in the past 12 months.<br><br> Plot by Ted Schurter 2023"

```


Create a the map and add the legend. 
```{r, echo=T, fig.height=11, fig.width=8.5}

# unclear why labels aren't showing up in rendered html; they'll remain for now.

# calculate center of one county for each rate/income rating matrix corner combination and assign x, y ####


# low abortion, low income county center point
lali_county <-  sf_biv %>% filter(year == 2021) %>% 
  select(Name, GEOID, rank, geometry) %>% 
  filter(rank == "la-li") %>% 
  slice(2) %>%  # can adjust slice to select needed la-li county 
  st_centroid(geometry)

lali_county <- do.call(rbind, st_geometry(lali_county))

lali_county_x <- lali_county[1]
lali_county_y <- lali_county[2]

# high abortion, high income county center point
hahi_county <-  sf_biv %>% filter(year == 2021) %>% 
  select(Name, GEOID, rank, geometry) %>% 
  filter(rank == "ha-hi") %>% 
  slice(2) %>%  # can adjust slice to select needed la-li county
  st_centroid(geometry)

hahi_county <- do.call(rbind, st_geometry(hahi_county))

hahi_county_x <- hahi_county[1]
hahi_county_y <- hahi_county[2]

# high abortion, low income county center point
hali_county <-  sf_biv %>% filter(year == 2021) %>% 
  select(Name, GEOID, rank, geometry) %>% 
  filter(rank == "ha-li") %>% 
  slice(1) %>%  # can adjust slice to select needed la-li county
  st_centroid(geometry)

hali_county <- do.call(rbind, st_geometry(hali_county))

hali_county_x <- hali_county[1]
hali_county_y <- hali_county[2]

# low abortion, high income county center point
lahi_county <-  sf_biv %>% filter(year == 2021) %>% 
  select(Name, GEOID, rank, geometry) %>% 
  filter(rank == "la-hi") %>% 
  slice(1) %>%  # can adjust slice to select needed la-li county
  st_centroid(geometry)

lahi_county <- do.call(rbind, st_geometry(lahi_county))

lahi_county_x <- lahi_county[1]
lahi_county_y <- lahi_county[2]

# add panel color 
panel_c <- "#fdfdf2"

# create plot 

p <- 
  ggplot()+
  geom_sf(data = sf_biv %>% filter(year == 2021),
          aes(fill=color),
          color = "white",
          size = 0.1,
          alpha = .95,
          show.legend = F)+
  scale_fill_identity()+
  # expand area around map to accomodate text labels
  coord_sf(xlim = c(-89, -84),
           ylim = c(37.75, 41.65),
           expand = TRUE)+
  theme_void()+
  theme(
    plot.margin = unit(c(.25, 1, 3, 1), "cm")
  )+
  #  main labels ####
labs(
  title = title,
  subtitle = s_title,
  caption = caption
)+
  # theme adjustments ####
theme(
  axis.text = element_blank(),
  axis.ticks = element_blank(),
  axis.line = element_blank(),
  panel.background = element_rect(color = NA,
                                  fill = panel_c),
  plot.background  = element_rect(color = NA,
                                  fill = panel_c),
  plot.title = element_textbox_simple(
    size = 22, lineheight = 1, family = "serif", padding = margin(.5, 5, 3, 1)),
  plot.subtitle = element_textbox_simple(
    size = 14, lineheight = 1, family = "sans", padding = margin(2, 0, 1, 0)),
  plot.caption = element_textbox_simple(
    size = 10, lineheight = 1.2, family = "sans", padding = margin(.5, 0, 1, 0),
    halign = 1),
  plot.caption.position = "plot"
)+
  # map annotations #### 
# low abortion low income county curve
geom_curve( 
  aes(
    x = lali_county_x/1.009,
    xend = lali_county_x,
    y = lali_county_y*1.004,
    yend = lali_county_y),
  curvature = -.2,
  linewidth = .75,
  color = "dark gray",
  arrow = arrow(
    length = unit(.2, "cm")))+  
  # low abortion low income county text
  annotate("text", lali_county_x/1.005, lali_county_y*1.008,
           colour = "black",
           size = 3.5,
           label = "Light gray counties\nmean low abortion\nand low income",
           lineheight = .9,
           hjust=0
  )+
  # high abortion high income county curve
  geom_curve( 
    aes(
      x = hahi_county_x*1.009,
      xend = hahi_county_x,
      y = hahi_county_y/1.003,
      yend = hahi_county_y),
    curvature = .2,
    linewidth = .75,
    color = "dark gray",
    arrow = arrow(
      length = unit(.2, "cm")))+
  # high abortion high income county text
  annotate("text", hahi_county_x*1.019, hahi_county_y/1.001,
           colour = "black",
           size = 3.5,
           label = "Dark bluegreen counties\nmean high abortion\nand high Income",
           lineheight = .9,
           hjust = 0
  )+
  # high abortion, low income county curve
  geom_curve( 
    aes(
      x = hali_county_x*1.009,
      xend = hali_county_x,
      y = hali_county_y/1.004,
      yend = hali_county_y),
    curvature = -.2,
    linewidth = .75,
    color = "dark gray",
    arrow = arrow(
      length = unit(.2, "cm")))+
  # high abortion, low income county text
  annotate("text", hali_county_x*1.0137, hali_county_y/1.0075,
           colour = "black",
           size = 3.5,
           label = "Blue counties\nmean high abortion\nand low income",
           lineheight = .9,
           hjust = 0
  )+
  # low abortion, high income county curve
  geom_curve( 
    aes(
      x = lahi_county_x/1.009,
      xend = lahi_county_x/1.0025,
      y = lahi_county_y*1.004,
      yend = lahi_county_y),
    curvature = -.2,
    linewidth = .75,
    color = "dark gray",
    arrow = arrow(
      length = unit(.2, "cm")))+
  # low abortion, high income county curve  
  annotate("text", lahi_county_x/1.004, lahi_county_y*1.0085,
           colour = "black",
           size = 3.5,
           label = "Green counties\nmean low abortion\nand high income",
           lineheight = .9,
           hjust = 0
  )

ggdraw() +
  draw_plot(p, 0, -.05, 1, 1) +
  draw_plot(legend, x=0.77, y=0.14, 0.13, 0.13, scale = 1.2)+
  theme(plot.background = element_rect(fill = panel_c, color = NA))


```

<br>

***

### Explore the data

<br><br>

```{r}
per_cap <- per_cap %>% 
  select(year, Name, fem_pop, Count, rate, annual_co_med, GEOID)

per_cap$year <- as.integer(per_cap$year)
colnames(per_cap) <- c("Year", "County\nname", "Female\npopulation", "Number of\nabortions", "Abortion\nrate\nper 1,000","Median\ncounty\nabortion\nrate", "GEOID")


in_med$GEOID <- as.character(in_med$GEOID)
in_med$geometry <- NULL
in_med <- in_med %>% 
  select(GEOID, estimate)
colnames(in_med) <- c("GEOID", "Median\nincome\nestimate")

table <- left_join(per_cap, in_med, by="GEOID")
table$GEOID <- NULL
table$geometry <- NULL

datatable(table, 
          rownames=FALSE, 
          filter = "top", 
          extensions = 'Buttons',
          options = list(pageLength=10, scrollX=T,dom = 'Bfrtip',
    buttons = c('csv', 'excel', 'pdf'))) %>% 
  formatCurrency("Median\nincome\nestimate", digits = 0)


```

